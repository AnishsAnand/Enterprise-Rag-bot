"""
Validation Agent - Validates parameters and collects missing information.
Ensures all required parameters are present and valid before execution.
"""

from typing import Any, Dict, List, Optional
from langchain.tools import Tool
import logging
import json
import re

from app.agents.base_agent import BaseAgent
from app.agents.state.conversation_state import conversation_state_manager
from app.services.api_executor_service import api_executor_service
from app.services.ai_service import ai_service
from app.agents.handlers.cluster_creation_handler import ClusterCreationHandler
from app.agents.tools.parameter_extraction import ParameterExtractor

logger = logging.getLogger(__name__)


class ValidationAgent(BaseAgent):
    """
    Agent specialized in parameter validation and collection.
    Validates parameters against schema, collects missing parameters conversationally.
    """

    def __init__(self):
        super().__init__(
            agent_name="ValidationAgent",
            agent_description=(
                "Validates parameters for CRUD operations and collects missing information. "
                "Ensures data quality and completeness before execution."
            ),
            temperature=0.2
        )

        # Initialize handlers and tools
        self.cluster_creation_handler = ClusterCreationHandler()
        self.param_extractor = ParameterExtractor()

        # Setup agent
        self.setup_agent()

    def get_system_prompt(self) -> str:
        """Return system prompt for validation agent."""
        return """You are the Validation Agent, responsible for ensuring all parameters are correct and complete.

**Your responsibilities:**
1. **Validate collected parameters** against schema rules
2. **Identify missing required parameters**
3. **Ask for missing information** in a conversational way
4. **Extract parameters** from user responses
5. **Provide helpful guidance** on parameter format and requirements
6. **Fetch available options dynamically** (endpoints, versions, etc.)
7. **Match user's natural language** to actual option values

**NEW CAPABILITIES:**
- Use `fetch_available_options` to get current data centers, versions, etc. from APIs
- Use `match_user_selection_to_options` to map user input like "delhi dc" to actual endpoint IDs
- NEVER hardcode location names or options - always fetch dynamically!
- Present actual available options to users - don't guess!

**Validation rules:**
- Check data types (string, integer, boolean, etc.)
- Validate string lengths (min/max)
- Check numeric ranges (min/max)
- Validate enum values
- Check regex patterns
- Ensure required parameters are present

**When asking for parameters:**
- Be conversational and friendly
- For options like data centers, FIRST fetch available options, THEN present them to user
- Explain why the parameter is needed
- Provide examples when helpful
- Ask for one or a few related parameters at a time (don't overwhelm user)
- If user provides partial information, acknowledge it and ask for remaining items

**Example interactions:**

Missing data center (SMART WAY):
"Let me check which data centers are available..."
[fetches endpoints dynamically]
"I found 5 data centers available:
- Delhi
- Bengaluru
- Mumbai-BKC
- Chennai-AMB
- Cressex

Which one would you like to use? You can also say 'all' to list clusters across all data centers."

User responds: "delhi dc"
[matches "delhi dc" to "Delhi" endpoint]
"Perfect! I'll use the Delhi data center."

Missing name:
"I'll help you create that Kubernetes cluster. What would you like to name it?
(Use lowercase letters, numbers, and hyphens only, 3-63 characters)"

Invalid parameter:
"The cluster name 'My_Cluster!' contains invalid characters.
Please use only lowercase letters, numbers, and hyphens (e.g., 'my-cluster-01')."

**IMPORTANT:**
- Always fetch current options - don't assume
- Match user input intelligently - "dc" could mean "data center"
- Ask for clarification when ambiguous
- Be helpful, patient, and guide users

Remember: You have tools to fetch real-time data and match user input intelligently. Use them!"""

    def get_tools(self) -> List[Tool]:
        """Return tools for validation agent."""
        return [
            Tool(
                name="validate_parameters",
                func=self._validate_parameters,
                description=(
                    "Validate parameters against schema. "
                    "Input: JSON with resource_type, operation, and params"
                )
            ),
            Tool(
                name="get_missing_params",
                func=self._get_missing_params,
                description=(
                    "Get list of missing required parameters for current operation. "
                    "Input: session_id"
                )
            ),
            Tool(
                name="extract_params_from_response",
                func=self._extract_params_from_response,
                description=(
                    "Extract parameter values from user's response. "
                    "Input: JSON with user_text and expected_params"
                )
            ),
            Tool(
                name="update_conversation_params",
                func=self._update_conversation_params,
                description=(
                    "Update conversation state with collected parameters. "
                    "Input: JSON with session_id and params"
                )
            ),
            Tool(
                name="fetch_available_options",
                func=self._fetch_available_options,
                description=(
                    "Fetch available options for a parameter from the API. "
                    "For example, fetch available data centers/endpoints dynamically. "
                    "Input: JSON with option_type (e.g., 'endpoints', 'zones', 'flavors')"
                )
            ),
            Tool(
                name="match_user_selection_to_options",
                func=self._match_user_selection,
                description=(
                    "Match user's natural language selection to available options. "
                    "For example, match 'delhi dc' or 'bengaluru' to actual endpoint names. "
                    "Input: JSON with user_text and available_options list"
                )
            )
        ]

    def _validate_parameters(self, input_json: str) -> str:
        """Validate parameters against schema."""
        try:
            data = json.loads(input_json)
            resource_type = data.get("resource_type")
            operation = data.get("operation")
            params = data.get("params", {})

            validation_result = api_executor_service.validate_parameters(
                resource_type, operation, params
            )

            return json.dumps(validation_result, indent=2)

        except Exception as e:
            return json.dumps({"valid": False, "errors": [str(e)]})

    def _get_missing_params(self, session_id: str) -> str:
        """Get missing parameters from conversation state."""
        try:
            state = conversation_state_manager.get_session(session_id)
            if not state:
                return json.dumps({"error": "Session not found"})

            return json.dumps({
                "missing_params": list(state.missing_params),
                "collected_params": list(state.collected_params.keys()),
                "invalid_params": state.invalid_params
            }, indent=2)

        except Exception as e:
            return json.dumps({"error": str(e)})

    def _extract_params_from_response(self, input_json: str) -> str:
        """Extract parameters from user response."""
        try:
            data = json.loads(input_json)
            user_text = data.get("user_text", "")
            expected_params = data.get("expected_params", [])

            # Simple extraction logic (can be enhanced with NER/LLM)
            extracted = {}

            # Try to match expected parameters in user text
            for param in expected_params:
                param_lower = param.lower()

                # Look for patterns like "name: value" or "name is value"
                import re
                pattern = rf'{param_lower}[:\s]+([^\s,]+)'
                match = re.search(pattern, user_text.lower())

                if match:
                    extracted[param] = match.group(1)
                elif len(expected_params) == 1:
                    # If only one parameter expected, assume entire input is the value
                    extracted[param] = user_text.strip()

            return json.dumps(extracted, indent=2)

        except Exception as e:
            return json.dumps({"error": str(e)})

    def _update_conversation_params(self, input_json: str) -> str:
        """Update conversation state with parameters."""
        try:
            data = json.loads(input_json)
            session_id = data.get("session_id")
            params = data.get("params", {})

            state = conversation_state_manager.get_session(session_id)
            if not state:
                return json.dumps({"success": False, "error": "Session not found"})

            # Add parameters to state
            state.add_parameters(params)

            # Check if ready to execute
            ready = state.is_ready_to_execute()

            return json.dumps({
                "success": True,
                "ready_to_execute": ready,
                "missing_params": list(state.missing_params)
            }, indent=2)

        except Exception as e:
            return json.dumps({"success": False, "error": str(e)})

    async def _fetch_available_options(self, option_type: str) -> str:
        """Fetch available options dynamically from API."""
        try:
            option_type_lower = option_type.lower().strip()

            if option_type_lower in ["endpoints", "endpoint", "data_centers", "datacenters", "dc", "locations"]:
                # Fetch available endpoints/data centers
                endpoints = await api_executor_service.get_endpoints()

                if endpoints:
                    formatted_options = []
                    for ep in endpoints:
                        formatted_options.append({
                            "id": ep.get("endpointId"),
                            "name": ep.get("endpointDisplayName"),
                            "type": ep.get("endpointType", ""),
                            "description": f"Data Center: {ep.get('endpointDisplayName')}"
                        })

                    return json.dumps({
                        "option_type": "endpoints",
                        "count": len(formatted_options),
                        "options": formatted_options,
                        "prompt_suggestion": (
                            f"I found {len(formatted_options)} available data centers:\n" +
                            "\n".join([f"- {opt['name']} (ID: {opt['id']})" for opt in formatted_options]) +
                            "\n\nWhich one would you like to use? You can say the name or 'all'."
                        )
                    }, indent=2)
                else:
                    return json.dumps({
                        "option_type": "endpoints",
                        "error": "No endpoints available",
                        "count": 0,
                        "options": []
                    })

            elif option_type_lower in ["k8s_versions", "kubernetes_versions", "versions"]:
                # Fetch available Kubernetes versions (you can add API call here)
                # For now, return common versions
                versions = ["v1.27.16", "v1.28.15", "v1.29.12", "v1.30.14"]
                formatted_options = [{"id": v, "name": v, "description": f"Kubernetes {v}"} for v in versions]

                return json.dumps({
                    "option_type": "k8s_versions",
                    "count": len(formatted_options),
                    "options": formatted_options,
                    "prompt_suggestion": (
                        "Available Kubernetes versions:\n" +
                        "\n".join([f"- {v}" for v in versions]) +
                        "\n\nWhich version would you like?"
                    )
                }, indent=2)

            else:
                return json.dumps({
                    "error": f"Unknown option type: {option_type}",
                    "supported_types": ["endpoints", "k8s_versions"]
                })

        except Exception as e:
            logger.error(f"Error fetching options: {e}")
            return json.dumps({"error": str(e)})

    async def _extract_location_from_query(self, input_json: str) -> str:
        """Use LLM to intelligently extract location/endpoint from user query."""
        try:
            data = json.loads(input_json)
            user_query = data.get("user_query", "")
            available_options = data.get("available_options", [])

            if not user_query or not available_options:
                return json.dumps({"extracted": False, "error": "Missing user_query or available_options"})

            # Build the prompt for LLM
            options_str = "\n".join([f"- {opt['name']}" for opt in available_options])

            prompt = f"""You are a location extraction specialist. Extract the data center/endpoint name(s) from the user's query.

Available Data Centers:
{options_str}

User Query: "{user_query}"

Instructions:
1. If user mentions SPECIFIC data center(s), return them comma-separated:
   - Single: "delhi" ‚Üí LOCATION: Delhi
   - Multiple: "delhi and bengaluru" ‚Üí LOCATION: Delhi, Bengaluru
2. If user says "all", "all clusters", "list all", "show all", etc. ‚Üí return "all"
3. If no specific location mentioned and no "all" ‚Üí return "none"

Examples:
- "list clusters in delhi" ‚Üí LOCATION: Delhi
- "show clusters in delhi and bengaluru" ‚Üí LOCATION: Delhi, Bengaluru
- "list all clusters" ‚Üí LOCATION: all
- "show all" ‚Üí LOCATION: all
- "list clusters" ‚Üí LOCATION: none
- "clusters in mumbai and chennai" ‚Üí LOCATION: Mumbai-BKC, Chennai-AMB

Respond with ONLY ONE of these formats:
- LOCATION: Delhi
- LOCATION: Delhi, Bengaluru
- LOCATION: all
- LOCATION: none"""

            response = await ai_service._call_chat_with_retries(
                prompt=prompt,
                max_tokens=50,
                temperature=0.0
            )

            result = response.strip()
            logger.info(f"ü§ñ LLM extraction result: '{result}'")

            # Parse the response
            if result.startswith("LOCATION:"):
                location = result.replace("LOCATION:", "").strip()
                if location.lower() == "none":
                    return json.dumps({"extracted": False})
                else:
                    return json.dumps({"extracted": True, "location": location})

            return json.dumps({"extracted": False})

        except Exception as e:
            logger.error(f"Error in LLM extraction: {e}")
            return json.dumps({"extracted": False, "error": str(e)})

    async def _match_user_selection(self, input_json: str) -> str:
        """Use LLM to intelligently match user's response to API results (NO primitive matching!)"""
        try:
            data = json.loads(input_json)
            user_text = data.get("user_text", "").strip()
            available_options = data.get("available_options", [])

            if not user_text or not available_options:
                return json.dumps({"matched": False, "error": "Missing user_text or available_options"})

            # === LLM-BASED MATCHING (NO PRIMITIVE PATTERNS!) ===
            # Build the list of available options for LLM
            options_list = "\n".join([f"  {i+1}. {opt['name']} (ID: {opt['id']})" for i, opt in enumerate(available_options)])

            matching_prompt = f"""Match the user's response to the correct data center(s) from the API response.

Available Data Centers (from API):
{options_list}

User's Response: "{user_text}"

Instructions:
1. If user says "all" or "all of them" ‚Üí return ALL IDs
2. If user mentions MULTIPLE locations (comma-separated or "and"), match ALL of them:
   - "Delhi, Bengaluru" ‚Üí match both Delhi (11) and Bengaluru (12)
   - "delhi and mumbai" ‚Üí match Delhi (11) and Mumbai-BKC (162)
3. Match user input to the correct data center (handle typos, abbreviations, spaces/hyphens):
   - "delhi" ‚Üí Delhi (ID: 11)
   - "chennai amb" ‚Üí Chennai-AMB (ID: 204)
   - "mumbai bkc" or "mumbai" ‚Üí Mumbai-BKC (ID: 162)
   - "bengaluru" or "bangalore" or "blr" ‚Üí Bengaluru (ID: 12)

Respond in JSON format ONLY:
{{
  "matched": true,
  "matched_ids": [11],
  "matched_names": ["Delhi"]
}}

For multiple locations:
{{
  "matched": true,
  "matched_ids": [11, 12],
  "matched_names": ["Delhi", "Bengaluru"]
}}

If no match:
{{
  "matched": false
}}"""

            # Call LLM to do the matching
            llm_response = await ai_service._call_chat_with_retries(
                prompt=matching_prompt,
                max_tokens=150,
                temperature=0.0
            )

            logger.info(f"ü§ñ LLM matching response: {llm_response[:150]}")

            # Extract JSON from LLM response
            import re
            json_match = re.search(r'\{[^{}]*\}', llm_response, re.DOTALL)
            if json_match:
                result = json.loads(json_match.group(0))
                if result.get("matched"):
                    matched_ids = result.get("matched_ids", [])
                    matched_names = result.get("matched_names", [])
                    
                    if len(matched_ids) == 1:
                        return json.dumps({
                            "matched": True,
                            "selection": "single",
                            "matched_ids": matched_ids,
                            "matched_names": matched_names
                        }, indent=2)
                    elif len(matched_ids) > 1:
                        return json.dumps({
                            "matched": True,
                            "selection": "multiple",
                            "matched_ids": matched_ids,
                            "matched_names": matched_names
                        }, indent=2)

            # No match
            return json.dumps({"matched": False, "no_match": True}, indent=2)

        except Exception as e:
            logger.error(f"Error matching selection: {e}")
            return json.dumps({"matched": False, "error": str(e)})
    
    async def _handle_cluster_creation(
        self,
        input_text: str,
        state: Any
    ) -> Dict[str, Any]:
        """
        Delegate cluster creation workflow to specialized handler.
        
        Args:
            input_text: User's current input
            state: Conversation state
            
        Returns:
            Dict with next prompt or ready_to_execute flag
        """
        logger.info(f"üéØ Delegating to ClusterCreationHandler")
        return await self.cluster_creation_handler.handle(input_text, state)

    async def _extract_location_from_query(
        self,
        user_query: str,
        available_endpoints: List[Dict[str, Any]]
    ) -> Optional[str]:
        """
        Delegate to ParameterExtractor tool.
        """
        return await self.param_extractor.extract_location_from_query(user_query, available_endpoints)
    
    async def _match_user_selection(
        self,
        input_text: str,
        available_options: List[Dict[str, Any]]
    ) -> str:
        """
        Delegate to ParameterExtractor tool.
        """
        return await self.param_extractor.match_user_selection(input_text, available_options)

    async def execute(
        self,
        input_text: str,
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Execute validation and parameter collection with INTELLIGENT tools.

        Args:
            input_text: User's response
            context: Context including session_id and conversation_state 
            "k8sVersion",
            "cniDriver",
            "businessUnit",
            "environment",
            "zone",
            "operatingSystem",
            "workerPoolName",
            "nodeType",
            "flavor",
            "replicaCount",
            "enableAutoscaling",  # optional
            "maxReplicas",  # conditional
            "tags"  # optional
        ]
        
        # Find the next parameter to collect
        next_param = None
        for param in workflow:
            if param not in state.collected_params:
                # Skip optional params based on user choice
                if param == "maxReplicas" and not state.collected_params.get("enableAutoscaling"):
                    continue
                if param in ["enableAutoscaling", "tags"] and input_text and "no" in input_text.lower():
                    # User declined optional param
                    continue
                    
                next_param = param
                break
        
        # If all parameters collected, mark as ready
        if next_param is None:
            logger.info(f"‚úÖ All cluster creation parameters collected!")
            state.status = "READY_TO_EXECUTE"
            state.missing_params = []
            
            # Build summary
            summary = f"""
**Cluster Creation Summary:**
- **Name**: {state.collected_params['clusterName']}
- **Datacenter**: {state.collected_params['datacenter']['name']}
- **Kubernetes**: {state.collected_params['k8sVersion']}
- **CNI Driver**: {state.collected_params['cniDriver']}
- **Business Unit**: {state.collected_params['businessUnit']['name']}
- **Environment**: {state.collected_params['environment']['name']}
- **Zone**: {state.collected_params['zone']['name']}
- **OS**: {state.collected_params['operatingSystem']['display_name']}
- **Worker Pool**: {state.collected_params['workerPoolName']} ({state.collected_params['replicaCount']} nodes)
- **Flavor**: {state.collected_params['flavor']['name']}
"""
            
            return {
                "agent_name": self.agent_name,
                "success": True,
                "ready_to_execute": True,
                "output": summary + "\n\nReady to create cluster! This will take 15-30 minutes. Shall I proceed?"
            }
        
        # If user provided input, try to process it for the last asked parameter
        if input_text and hasattr(state, 'last_asked_param') and state.last_asked_param:
            last_param = state.last_asked_param
            logger.info(f"üìù Processing user input for: {last_param}")
            
            # Handle each parameter type
            if last_param == "clusterName":
                # Validate cluster name format
                cluster_name = input_text.strip()
                if not re.match(r'^[a-zA-Z][a-zA-Z0-9-]{2,17}$', cluster_name):
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "Cluster name must start with a letter and be 3-18 characters (letters, numbers, hyphens). Please try again:"
                    }
                
                # Check availability (using sample API for now)
                check_result = await api_executor_service.check_cluster_name_available(cluster_name)
                if not check_result.get("available"):
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": f"Cluster name '{cluster_name}' is already taken. Please choose another name:"
                    }
                
                state.collected_params["clusterName"] = cluster_name
                next_param = "datacenter"
            
            elif last_param == "datacenter":
                # Fetch datacenters first if not cached
                if not hasattr(state, '_datacenter_options'):
                    engagement_id = await api_executor_service.get_engagement_id()
                    dc_result = await api_executor_service.get_iks_images_and_datacenters(engagement_id)
                    state._datacenter_options = dc_result.get("datacenters", [])
                    state._all_images = dc_result.get("images", [])
                
                # Match user selection
                matched = await self._match_user_selection(input_text, state._datacenter_options)
                matched_data = json.loads(matched)
                
                if matched_data.get("matched"):
                    dc_info = matched_data.get("matched_item")
                    state.collected_params["datacenter"] = dc_info
                    state.collected_params["_datacenter_id"] = dc_info["id"]
                    next_param = "k8sVersion"
                else:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "I couldn't match that datacenter. Please choose from the list above:"
                    }
            
            elif last_param == "k8sVersion":
                # Get k8s versions for selected datacenter
                if not hasattr(state, '_k8s_versions'):
                    dc_id = state.collected_params["_datacenter_id"]
                    versions = await api_executor_service.get_k8s_versions_for_datacenter(
                        dc_id, 
                        state._all_images
                    )
                    state._k8s_versions = versions
                
                # Match user selection
                if input_text.strip() in state._k8s_versions:
                    state.collected_params["k8sVersion"] = input_text.strip()
                    next_param = "cniDriver"
                else:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "Please select one of the versions listed above:"
                    }
            
            elif last_param == "cniDriver":
                # Get CNI drivers
                if not hasattr(state, '_cni_drivers'):
                    dc_id = state.collected_params["_datacenter_id"]
                    k8s_version = state.collected_params["k8sVersion"]
                    driver_result = await api_executor_service.get_network_drivers(dc_id, k8s_version)
                    state._cni_drivers = driver_result.get("drivers", [])
                
                # Match user selection
                if input_text.strip() in state._cni_drivers:
                    state.collected_params["cniDriver"] = input_text.strip()
                    next_param = "businessUnit"
                else:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "Please select one of the CNI drivers listed above:"
                    }
            
            elif last_param == "businessUnit":
                # Get business units
                if not hasattr(state, '_business_units'):
                    engagement_id = await api_executor_service.get_engagement_id()
                    env_result = await api_executor_service.get_environments_and_business_units(engagement_id)
                    state._business_units = env_result.get("business_units", [])
                    state._all_environments = env_result.get("environments", [])
                
                # Match user selection
                matched = await self._match_user_selection(input_text, state._business_units)
                matched_data = json.loads(matched)
                
                if matched_data.get("matched"):
                    bu_info = matched_data.get("matched_item")
                    state.collected_params["businessUnit"] = bu_info
                    next_param = "environment"
                else:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "I couldn't match that business unit. Please choose from the list above:"
                    }
            
            elif last_param == "environment":
                # Filter environments by selected BU
                bu_id = state.collected_params["businessUnit"]["id"]
                filtered_envs = [env for env in state._all_environments if env["departmentId"] == bu_id]
                
                # Match user selection
                env_options = [{"id": env["id"], "name": env["name"]} for env in filtered_envs]
                matched = await self._match_user_selection(input_text, env_options)
                matched_data = json.loads(matched)
                
                if matched_data.get("matched"):
                    env_info = matched_data.get("matched_item")
                    # Store full environment data
                    full_env = next(e for e in filtered_envs if e["id"] == env_info["id"])
                    state.collected_params["environment"] = {"id": full_env["id"], "name": full_env["name"]}
                    state.collected_params["_environment_name"] = full_env["name"]
                    next_param = "zone"
                else:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "I couldn't match that environment. Please choose from the list above:"
                    }
            
            elif last_param == "zone":
                # Get zones
                if not hasattr(state, '_zones'):
                    engagement_id = await api_executor_service.get_engagement_id()
                    zone_result = await api_executor_service.get_zones_list(engagement_id)
                    state._zones = zone_result.get("zones", [])
                
                # Filter zones by BU and environment
                bu_name = state.collected_params["businessUnit"]["name"]
                env_name = state.collected_params["_environment_name"]
                filtered_zones = [z for z in state._zones 
                                 if z["departmentName"] == bu_name and z["environmentName"] == env_name]
                
                # Match user selection
                zone_options = [{"id": z["zoneId"], "name": z["zoneName"]} for z in filtered_zones]
                matched = await self._match_user_selection(input_text, zone_options)
                matched_data = json.loads(matched)
                
                if matched_data.get("matched"):
                    zone_info = matched_data.get("matched_item")
                    state.collected_params["zone"] = zone_info
                    state.collected_params["_zone_id"] = zone_info["id"]
                    next_param = "operatingSystem"
                else:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "I couldn't match that zone. Please choose from the list above:"
                    }
            
            elif last_param == "operatingSystem":
                # Get OS images
                if not hasattr(state, '_os_options'):
                    zone_id = state.collected_params["_zone_id"]
                    circuit_id = await api_executor_service.get_circuit_id(None)
                    k8s_version = state.collected_params["k8sVersion"]
                    os_result = await api_executor_service.get_os_images(zone_id, circuit_id, k8s_version)
                    state._os_options = os_result.get("os_options", [])
                    state._circuit_id = circuit_id
                
                # Match user selection
                os_options = [{"id": i, "name": opt["display_name"]} for i, opt in enumerate(state._os_options)]
                matched = await self._match_user_selection(input_text, os_options)
                matched_data = json.loads(matched)
                
                if matched_data.get("matched"):
                    os_idx = matched_data.get("matched_item")["id"]
                    state.collected_params["operatingSystem"] = state._os_options[os_idx]
                    next_param = "workerPoolName"
                else:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "I couldn't match that OS. Please choose from the list above:"
                    }
            
            elif last_param == "workerPoolName":
                # Validate worker pool name (5 lowercase alphanumeric chars)
                pool_name = input_text.strip().lower()
                if not re.match(r'^[a-z0-9]{1,5}$', pool_name):
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "Worker pool name must be 1-5 lowercase alphanumeric characters. Please try again:"
                    }
                
                state.collected_params["workerPoolName"] = pool_name
                next_param = "nodeType"
            
            elif last_param == "nodeType":
                # Get flavors first to determine node types
                if not hasattr(state, '_node_types'):
                    zone_id = state.collected_params["_zone_id"]
                    circuit_id = state._circuit_id
                    os_model = state.collected_params["operatingSystem"]["os_model"]
                    flavor_result = await api_executor_service.get_flavors(zone_id, circuit_id, os_model)
                    state._node_types = flavor_result.get("node_types", [])
                    state._all_flavors = flavor_result.get("flavors", [])
                
                # Map display names
                node_type_map = {
                    "general": "generalPurpose",
                    "compute": "computeOptimized",
                    "memory": "memoryOptimized"
                }
                
                # Try to match user input
                user_input_lower = input_text.lower()
                matched_type = None
                for key, value in node_type_map.items():
                    if key in user_input_lower and value in state._node_types:
                        matched_type = value
                        break
                
                if matched_type:
                    state.collected_params["nodeType"] = matched_type
                    next_param = "flavor"
                else:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "Please choose General Purpose, Compute Optimized, or Memory Optimized:"
                    }
            
            elif last_param == "flavor":
                # Filter flavors by node type
                node_type = state.collected_params["nodeType"]
                filtered_flavors = [f for f in state._all_flavors if f["node_type"] == node_type]
                
                # Try to match user selection (by index or description)
                flavor_options = [{"id": f["id"], "name": f["name"]} for f in filtered_flavors]
                matched = await self._match_user_selection(input_text, flavor_options)
                matched_data = json.loads(matched)
                
                if matched_data.get("matched"):
                    flavor_id = matched_data.get("matched_item")["id"]
                    flavor_info = next(f for f in filtered_flavors if f["id"] == flavor_id)
                    state.collected_params["flavor"] = flavor_info
                    next_param = "replicaCount"
                else:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "I couldn't match that flavor. Please choose from the list above:"
                    }
            
            elif last_param == "replicaCount":
                # Validate replica count (1-8)
                try:
                    count = int(input_text.strip())
                    if 1 <= count <= 8:
                        state.collected_params["replicaCount"] = count
                        next_param = "enableAutoscaling"
                    else:
                        return {
                            "agent_name": self.agent_name,
                            "success": True,
                            "output": "Replica count must be between 1 and 8. Please try again:"
                        }
                except ValueError:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "Please enter a number between 1 and 8:"
                    }
            
            elif last_param == "enableAutoscaling":
                # Optional yes/no
                user_response = input_text.lower().strip()
                if "yes" in user_response or "enable" in user_response:
                    state.collected_params["enableAutoscaling"] = True
                    next_param = "maxReplicas"
                elif "no" in user_response or "skip" in user_response:
                    state.collected_params["enableAutoscaling"] = False
                    next_param = "tags"
                else:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": "Please answer 'yes' or 'no' for autoscaling:"
                    }
            
            elif last_param == "maxReplicas":
                # Validate max replicas (1-8, must be >= replicaCount)
                try:
                    max_count = int(input_text.strip())
                    min_count = state.collected_params["replicaCount"]
                    if min_count <= max_count <= 8:
                        state.collected_params["maxReplicas"] = max_count
                        next_param = "tags"
                    else:
                        return {
                            "agent_name": self.agent_name,
                            "success": True,
                            "output": f"Max replicas must be between {min_count} and 8. Please try again:"
                        }
                except ValueError:
                    return {
                        "agent_name": self.agent_name,
                        "success": True,
                        "output": f"Please enter a number between {state.collected_params['replicaCount']} and 8:"
                    }
            
            elif last_param == "tags":
                # Optional tags (skip for now in MVP)
                user_response = input_text.lower().strip()
                if "no" in user_response or "skip" in user_response:
                    state.collected_params["tags"] = []
                    next_param = None  # Done!
                else:
                    # TODO: Implement tag collection in future
                    state.collected_params["tags"] = []
                    next_param = None
        
        # Now ask for the next parameter
        if next_param:
            state.last_asked_param = next_param
            return await self._ask_for_parameter(next_param, state)
        
        # Should not reach here
        return {
            "agent_name": self.agent_name,
            "success": False,
            "output": "Something went wrong with the cluster creation flow. Please start over."
        }
    
    async def _ask_for_parameter(self, param_name: str, state: Any) -> Dict[str, Any]:
        """
        Ask user for a specific parameter with context.
        
        Args:
            param_name: Name of parameter to ask for
            state: Conversation state
            
        Returns:
            Dict with prompt for user
        """
        logger.info(f"‚ùì Asking for parameter: {param_name}")
        
        # Get conversational prompts from schema
        schema = self.resource_schema["resources"]["k8s_cluster"]["parameters"]["create"]
        prompts = schema.get("conversational_prompts", {})
        
        # Build prompt based on parameter
        if param_name == "clusterName":
            prompt = prompts.get("clusterName", "What would you like to name your cluster?")
            output = prompt
        
        elif param_name == "datacenter":
            # Fetch datacenters if not already fetched
            if not hasattr(state, '_datacenter_options'):
                engagement_id = await api_executor_service.get_engagement_id()
                dc_result = await api_executor_service.get_iks_images_and_datacenters(engagement_id)
                state._datacenter_options = dc_result.get("datacenters", [])
                state._all_images = dc_result.get("images", [])
            
            dc_list = "\n".join([f"- {dc['name']}" for dc in state._datacenter_options])
            output = f"{prompts.get('datacenter', 'Which data center?')}\n\nAvailable data centers:\n{dc_list}"
        
        elif param_name == "k8sVersion":
            # Get k8s versions for selected datacenter
            dc_id = state.collected_params["_datacenter_id"]
            versions = await api_executor_service.get_k8s_versions_for_datacenter(dc_id, state._all_images)
            state._k8s_versions = versions
            
            version_list = "\n".join([f"- {v}" for v in versions])
            output = f"{prompts.get('k8sVersion', 'Which Kubernetes version?')}\n\nAvailable versions:\n{version_list}"
        
        elif param_name == "cniDriver":
            # Get CNI drivers
            dc_id = state.collected_params["_datacenter_id"]
            k8s_version = state.collected_params["k8sVersion"]
            driver_result = await api_executor_service.get_network_drivers(dc_id, k8s_version)
            state._cni_drivers = driver_result.get("drivers", [])
            
            driver_list = "\n".join([f"- {d}" for d in state._cni_drivers])
            output = f"{prompts.get('cniDriver', 'Which CNI driver?')}\n\nAvailable drivers:\n{driver_list}"
        
        elif param_name == "businessUnit":
            # Get business units
            engagement_id = await api_executor_service.get_engagement_id()
            env_result = await api_executor_service.get_environments_and_business_units(engagement_id)
            state._business_units = env_result.get("business_units", [])
            state._all_environments = env_result.get("environments", [])
            
            bu_list = "\n".join([f"- {bu['name']}" for bu in state._business_units])
            output = f"{prompts.get('businessUnit', 'Which business unit?')}\n\nAvailable business units:\n{bu_list}"
        
        elif param_name == "environment":
            # Filter environments by selected BU
            bu_id = state.collected_params["businessUnit"]["id"]
            filtered_envs = [env for env in state._all_environments if env["departmentId"] == bu_id]
            
            env_list = "\n".join([f"- {env['name']}" for env in filtered_envs])
            output = f"{prompts.get('environment', 'Which environment?')}\n\nAvailable environments:\n{env_list}"
        
        elif param_name == "zone":
            # Get and filter zones
            engagement_id = await api_executor_service.get_engagement_id()
            zone_result = await api_executor_service.get_zones_list(engagement_id)
            state._zones = zone_result.get("zones", [])
            
            bu_name = state.collected_params["businessUnit"]["name"]
            env_name = state.collected_params["_environment_name"]
            filtered_zones = [z for z in state._zones 
                             if z["departmentName"] == bu_name and z["environmentName"] == env_name]
            
            zone_list = "\n".join([f"- {z['zoneName']}" for z in filtered_zones])
            output = f"{prompts.get('zone', 'Which network zone?')}\n\nAvailable zones:\n{zone_list}"
        
        elif param_name == "operatingSystem":
            # Get OS images
            zone_id = state.collected_params["_zone_id"]
            circuit_id = await api_executor_service.get_circuit_id(None)
            k8s_version = state.collected_params["k8sVersion"]
            os_result = await api_executor_service.get_os_images(zone_id, circuit_id, k8s_version)
            state._os_options = os_result.get("os_options", [])
            state._circuit_id = circuit_id
            
            os_list = "\n".join([f"- {opt['display_name']}" for opt in state._os_options])
            output = f"{prompts.get('operatingSystem', 'Which operating system?')}\n\nAvailable OS options:\n{os_list}"
        
        elif param_name == "workerPoolName":
            output = prompts.get("workerNodePool", {}).get("poolName", "Worker pool name? (5 lowercase alphanumeric chars)")
        
        elif param_name == "nodeType":
            # Get node types from flavors
            zone_id = state.collected_params["_zone_id"]
            circuit_id = state._circuit_id
            os_model = state.collected_params["operatingSystem"]["os_model"]
            flavor_result = await api_executor_service.get_flavors(zone_id, circuit_id, os_model)
            state._node_types = flavor_result.get("node_types", [])
            state._all_flavors = flavor_result.get("flavors", [])
            
            # Display friendly names
            type_display = {
                "generalPurpose": "General Purpose",
                "computeOptimized": "Compute Optimized",
                "memoryOptimized": "Memory Optimized"
            }
            type_list = "\n".join([f"- {type_display.get(t, t)}" for t in state._node_types])
            output = f"{prompts.get('workerNodePool', {}).get('nodeType', 'Which node type?')}\n\nAvailable types:\n{type_list}"
        
        elif param_name == "flavor":
            # Filter flavors by node type
            node_type = state.collected_params["nodeType"]
            filtered_flavors = [f for f in state._all_flavors if f["node_type"] == node_type]
            
            flavor_list = "\n".join([f"- {f['name']}" for f in filtered_flavors])
            output = f"{prompts.get('workerNodePool', {}).get('flavor', 'Which flavor?')}\n\nAvailable flavors:\n{flavor_list}"
        
        elif param_name == "replicaCount":
            output = prompts.get("workerNodePool", {}).get("replicaCount", "How many worker nodes? (1-8)")
        
        elif param_name == "enableAutoscaling":
            output = prompts.get("workerNodePool", {}).get("enableAutoscaling", "Enable autoscaling? (yes/no)")
        
        elif param_name == "maxReplicas":
            min_count = state.collected_params["replicaCount"]
            output = f"{prompts.get('workerNodePool', {}).get('maxReplicas', 'Max replicas?')} ({min_count}-8)"
        
        elif param_name == "tags":
            output = prompts.get("tags", "Would you like to add any tags? (yes/no, or 'no' to skip)")
        
        else:
            output = f"Please provide: {param_name}"
        
        return {
            "agent_name": self.agent_name,
            "success": True,
            "output": output
        }

    async def execute(
        self,
        input_text: str,
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Execute validation and parameter collection with INTELLIGENT tools.

        Args:
            input_text: User's response
            context: Context including session_id and conversation_state

        Returns:
            Dict with validation result
        """
        try:
            logger.info(f"‚úÖ ValidationAgent processing: {input_text[:100]}...")

            # Get conversation state
            session_id = context.get("session_id") if context else None
            state = conversation_state_manager.get_session(session_id) if session_id else None

            if not state:
                return {
                    "agent_name": self.agent_name,
                    "success": False,
                    "error": "No conversation state found",
                    "output": "I couldn't find our conversation. Let's start over."
                }

            # STEP 3: USE INTELLIGENT TOOLS for parameter collection
            if state.missing_params:
                # SPECIAL HANDLING FOR K8S CLUSTER CREATION (CUSTOMER WORKFLOW)
                if state.operation == "create" and state.resource_type == "k8s_cluster":
                    logger.info("üéØ Routing to customer cluster creation workflow")
                    return await self._handle_cluster_creation(input_text, state)
                
                # SPECIAL HANDLING FOR OTHER CREATE OPERATIONS
                # For create, we need to collect params in order: name ‚Üí endpoint ‚Üí other params
                elif state.operation == "create":
                    # Check what's missing and prioritize logical order
                    param_priority = ["clusterName", "name", "endpoint_id", "endpoints"]

                    # Find the first missing param in priority order
                    next_param_to_collect = None
                    for priority_param in param_priority:
                        if priority_param in state.missing_params:
                            next_param_to_collect = priority_param
                            break

                    # If user provided input, try to extract the parameter value using LLM
                    if input_text and next_param_to_collect and "endpoint" not in next_param_to_collect.lower():
                        logger.info(f"ü§ñ Using LLM to extract {next_param_to_collect} from: '{input_text}'")
                        
                        # Use LLM to understand if user provided the value
                        extraction_prompt = f"""User was asked to provide '{next_param_to_collect}' for creating a Kubernetes cluster.
User's response: "{input_text}"

Is the user providing a value for {next_param_to_collect}? Extract it.

Respond with ONLY ONE of these formats:
- VALUE: <extracted_value>
- UNCLEAR: <reason>

Examples:
User response: "tchl-paas-dev-vcp" ‚Üí VALUE: tchl-paas-dev-vcp
User response: "I want to name it myCluster" ‚Üí VALUE: myCluster  
User response: "something" ‚Üí VALUE: something
User response: "what should I name it?" ‚Üí UNCLEAR: User is asking a question
"""
                        
                        try:
                            llm_response = await ai_service._call_chat_with_retries(
                                prompt=extraction_prompt,
                                max_tokens=100,
                                temperature=0.0
                            )

                            result = llm_response.strip()
                            logger.info(f"ü§ñ LLM extraction result: '{result}'")
                            
                            if result.startswith("VALUE:"):
                                extracted_value = result.replace("VALUE:", "").strip()
                                logger.info(f"‚úÖ Extracted {next_param_to_collect} = '{extracted_value}'")
                                
                                # Add parameter to state
                                state.add_parameter(next_param_to_collect, extracted_value, is_valid=True)
                                
                                # Continue to next missing param or endpoint collection
                                # Don't return here, let it flow to endpoint collection or completion check
                                
                        except Exception as e:
                            logger.error(f"Error in LLM extraction: {e}")
                    
                    # If still missing the same param (LLM couldn't extract), ask again
                    if next_param_to_collect and next_param_to_collect in state.missing_params and "endpoint" not in next_param_to_collect.lower():
                        logger.info(f"üîç CREATE workflow: Still need {next_param_to_collect}")

                        # Ask for the parameter conversationally
                        response = f"Great! Let's create a new Kubernetes cluster.\n\n"

                        if "name" in next_param_to_collect.lower():
                            response += "What would you like to name your cluster?"
                        else:
                            response += f"Please provide: {next_param_to_collect}"

                        return {
                            "agent_name": self.agent_name,
                            "success": True,
                            "output": response,
                            "ready_to_execute": False,
                            "missing_params": list(state.missing_params),
                            "next_param": next_param_to_collect
                        }

                # Check if we need endpoint/datacenter parameter
                if "endpoints" in state.missing_params or "endpoint_id" in state.missing_params or "endpoint_ids" in state.missing_params:
                    logger.info("üîç Collecting endpoint parameter using intelligent tools")

                    # Fetch available endpoints dynamically
                    endpoints_json = await self._fetch_available_options("endpoints")
                    endpoints_data = json.loads(endpoints_json)

                    if endpoints_data.get("options"):
                        available_options = endpoints_data["options"]

                        # ALWAYS use input_text for NEW requests (not cached state.user_query!)
                        # Only use state.user_query if this is a follow-up response to "Which endpoint?"
                        # We detect follow-up by checking if we already asked a question
                        is_follow_up = len(state.conversation_history) > 1 and any(
                            "which one would you like" in msg.get("content", "").lower()
                            for msg in state.conversation_history if msg.get("role") == "assistant"
                        )
                        
                        text_to_analyze = input_text if not is_follow_up else input_text
                        logger.info(f"üîç Analyzing query: '{text_to_analyze}' for location extraction (is_follow_up: {is_follow_up})")

                        # USE LLM FOR INTELLIGENT EXTRACTION (not primitive pattern matching!)
                        extraction_result_json = await self._extract_location_from_query(json.dumps({
                            "user_query": text_to_analyze,
                            "available_options": available_options
                        }))
                        extraction_result = json.loads(extraction_result_json)

                        if extraction_result.get("extracted"):
                            # LLM extracted a location!
                            extracted_location = extraction_result.get("location", "")
                            logger.info(f"ü§ñ LLM extracted location: '{extracted_location}'")
                            text_to_match = extracted_location
                        else:
                            # No location in original query, use current input for matching
                            text_to_match = input_text
                            logger.info(f"üîç No location in query, using current input: '{text_to_match}'")

                        # Try to match user input to available endpoints (LLM-based!)
                        match_result_json = await self._match_user_selection(json.dumps({
                            "user_text": text_to_match,
                            "available_options": available_options
                        }))
                        match_result = json.loads(match_result_json)

                        if match_result.get("matched"):
                            # Successfully matched!
                            matched_ids = match_result.get("matched_ids", [])
                            matched_names = match_result.get("matched_names", [])
                            logger.info(f"‚úÖ Matched '{input_text}' to {matched_names} (IDs: {matched_ids})")

                            # Add to state
                            state.add_parameter("endpoints", matched_ids, is_valid=True)
                            state.add_parameter("endpoint_names", matched_names, is_valid=True)

                        elif match_result.get("ambiguous"):
                            # Multiple matches - ask for clarification
                            clarification = match_result.get("clarification_needed", "")
                            
                            # Set status to COLLECTING_PARAMS
                            from app.agents.state.conversation_state import ConversationStatus
                            state.status = ConversationStatus.COLLECTING_PARAMS
                            
                            return {
                                "agent_name": self.agent_name,
                                "success": True,
                                "output": clarification,
                                "ready_to_execute": False,
                                "missing_params": list(state.missing_params)
                            }
                        else:
                            # No match - show available options
                            prompt = endpoints_data.get("prompt_suggestion", "")
                            if not prompt:
                                options_list = "\n".join([f"- {opt['name']}" for opt in available_options])
                                prompt = f"I found {len(available_options)} available data centers:\n{options_list}\n\nWhich one would you like? You can also say 'all'."

                            # CRITICAL: Set status to COLLECTING_PARAMS so orchestrator knows to continue conversation
                            from app.agents.state.conversation_state import ConversationStatus
                            state.status = ConversationStatus.COLLECTING_PARAMS
                            logger.info(f"üîÑ Set conversation status to COLLECTING_PARAMS for session {state.session_id}")

                            return {
                                "agent_name": self.agent_name,
                                "success": True,
                                "output": prompt,
                                "ready_to_execute": False,
                                "missing_params": list(state.missing_params),
                                "available_options": available_options
                            }
                    else:
                        # Couldn't fetch endpoints
                        return {
                            "agent_name": self.agent_name,
                            "success": False,
                            "output": "I couldn't fetch the available data centers. Please try again.",
                            "error": endpoints_data.get("error")
                        }

                # For other parameters, use simple extraction
                else:
                    extracted_params = self._simple_param_extraction(input_text, state.missing_params)

                    if extracted_params:
                        # Validate extracted parameters
                        validation_result = api_executor_service.validate_parameters(
                            state.resource_type,
                            state.operation,
                            {**state.collected_params, **extracted_params}
                        )

                        # Add valid parameters to state
                        for param_name, param_value in extracted_params.items():
                            if validation_result["valid"] or param_name not in validation_result.get("errors", []):
                                state.add_parameter(param_name, param_value, is_valid=True)
                            else:
                                param_errors = [e for e in validation_result.get("errors", []) if param_name in e]
                                error_msg = param_errors[0] if param_errors else "Invalid value"
                                state.mark_parameter_invalid(param_name, error_msg)

            # Check if ready to execute
            if state.is_ready_to_execute():
                response = (
                    f"Perfect! I have all the information needed to {state.operation} the {state.resource_type}.\n\n"
                    f"**Summary:**\n"
                )
                for param, value in state.collected_params.items():
                    response += f"- {param}: {value}\n"

                response += "\nShall I proceed with this operation?"

                return {
                    "agent_name": self.agent_name,
                    "success": True,
                    "output": response,
                    "ready_to_execute": True
                }

            # Generate response asking for missing parameters
            response = self._generate_collection_message(state)

            return {
                "agent_name": self.agent_name,
                "success": True,
                "output": response,
                "ready_to_execute": False,
                "missing_params": list(state.missing_params)
            }

        except Exception as e:
            logger.error(f"‚ùå Validation failed: {str(e)}")
            return {
                "agent_name": self.agent_name,
                "success": False,
                "error": str(e),
                "output": f"I encountered an error while validating: {str(e)}"
            }

    def _simple_param_extraction(
        self,
        user_text: str,
        expected_params: set
    ) -> Dict[str, Any]:
        """
        Simple parameter extraction from user text.

        Args:
            user_text: User's input text
            expected_params: Set of expected parameter names

        Returns:
            Dict of extracted parameters
        """
        extracted = {}

        # If only one parameter expected and input is simple, use entire input
        if len(expected_params) == 1:
            param_name = list(expected_params)[0]
            extracted[param_name] = user_text.strip()
        else:
            # Try to extract multiple parameters
            import re
            for param in expected_params:
                # Look for "param: value" or "param = value" patterns
                pattern = rf'{re.escape(param)}[:\s=]+([^\n,]+)'
                match = re.search(pattern, user_text, re.IGNORECASE)

                if match:
                    extracted[param] = match.group(1).strip()

        return extracted

    def _generate_collection_message(self, state) -> str:
        """
        Generate a message asking for missing parameters.

        Args:
            state: Conversation state

        Returns:
            Message string
        """
        if not state.missing_params:
            return "All parameters collected!"

        # Show invalid parameters first
        message = ""
        if state.invalid_params:
            message += "I noticed some issues with the information provided:\n"
            for param, error in state.invalid_params.items():
                message += f"- {param}: {error}\n"
            message += "\n"

        # Ask for missing parameters
        missing_list = sorted(state.missing_params)

        if len(missing_list) == 1:
            param = missing_list[0]
            message += f"I need one more thing: **{param}**. Could you provide that?"
        elif len(missing_list) <= 3:
            message += "I need a few more details:\n"
            for param in missing_list:
                message += f"- {param}\n"
            message += "\nYou can provide these all at once or one at a time."
        else:
            # Show first 3 parameters
            message += "I need several more details. Let's start with these:\n"
            for param in missing_list[:3]:
                message += f"- {param}\n"
            message += f"\n(Plus {len(missing_list) - 3} more after these)"

        return message
